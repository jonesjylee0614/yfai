先给个结论：
你现在的 YFAI 已经是“本地 AI 控制台 + 工具中枢”的雏形，但还停留在“单次对话 + 手动点工具”的阶段。
要变成真正“帮你干活的智能体工作台”，核心要补三块：

1. 有状态的智能体 / Workflow（能自己分解任务、循环调用工具）
2. 自动化与调度（按时间/事件触发，不用你每次手动）
3. 对外连接与可扩展（统一的 Connector / 集成层，而不是零散 MCP）

下面我按「新增模块 / 功能」+「对现有模块的改造」来梳理，开发同学直接照着就能开工。

---

## 一、新增功能模块总览

建议在现有架构上增加 6 个明确的子模块：

1. Agent Center：智能体与 Workflow 中心
2. Automation Center：调度与触发器
3. Connector Framework：对外服务集成层
4. Job & Run 观测台：任务运行可视化与重放
5. Personal Workspace：个人工作流场景（预置几个“可直接用”的场景）
6. 安全 & 权限细化：到“智能体/任务级”的工具授权

下面详细展开。

---

## 二、Agent Center：智能体与 Workflow 中心

### 2.1 功能目标

* 从“单轮对话 + 临时工具调用”升级为：

  * 可配置的「智能体」（AgentProfile）
  * 支持多步计划 / 执行（Workflow）
  * 支持循环：直到满足某个条件自动停止

### 2.2 新增功能点

1. Agent 定义与管理

   * UI：新增「助手/智能体」页（你原型里已有助手管理，直接落地）：

     * 字段：名称、描述、系统提示词（system_prompt）、默认模型、可用工具列表（LocalOps/MCP/Connectors）、风险级别
     * 开启/关闭 Agent（启用时才出现在侧栏/命令面板）
   * 后端：新增模型 `Agent`（`yfai/store/db.py`）：

     * `id`, `name`, `description`, `system_prompt`, `default_model`, `allowed_tools (json)`, `max_steps`, `stop_condition (json)`, `is_enabled`

2. Workflow/Plan 执行

   * 在 Orchestrator 上层增加一个 `AgentRunner`：

     * 输入：用户目标（goal）、选中的 Agent
     * 步骤：

       1. 调用 LLM 生成 Plan（step list）
       2. 按顺序执行步骤：每步可能是“调用工具 / 再问 LLM / 更新知识库”
       3. 记录每一步的执行结果为 JobStep（见 Job & Run 模块）
   * 支持“中途插手”：

     * UI 中展示 plan 步骤列表，可手动跳过 / 重跑某一步

3. 预置 Agent 场景（满足你“自己用”的刚需）

   先给几个实用的内置 Agent：

   * DevOps 助手

     * 能：拉仓库、本地构建、跑单测、压缩日志、生成报告
     * 绑定工具：ShellOps、ProcessOps、FsOps、NetOps、一两个 MCP DevOps server
   * 知识整理助手

     * 能：扫描指定目录 Markdown/PDF，分块建库，定期总结变化
     * 绑定工具：FsOps、VectorIndexer、Bailian/Ollama Chat、知识库 RAG API
   * 系统巡检助手

     * 能：定时跑 CPU/RAM/磁盘/网络状态，生成日报写入本地文件
     * 绑定工具：ProcessOps、NetOps、FsOps

4. Agent 执行模式

   * 在 ChatWidget 中新增模式切换：

     * 普通对话模式：经典 Chat
     * 计划执行模式：`/run-as-agent <AgentName>`，进入 workflow 模式
   * 命令面板中增加命令：

     * “使用 XX 智能体处理当前会话”

### 2.3 代码改造点

* `yfai/core/orchestrator.py`

  * 新增 `run_agent(agent_id, goal: str)` 方法
  * 新增对 Workflow 执行的统一接口（内部循环调用 provider + tools）
* `yfai/store/db.py`

  * 新增 `Agent` 表
  * （可选）新增 `WorkflowTemplate` 表，用于保存常用 workflow 模板
* UI：

  * `Sidebar` 新增 “智能体”入口（你已有，可以映射到真实数据）
  * 新增 Agent 管理页面 + Agent 详情（绑定模型与工具）

---

## 三、Automation Center：调度与触发器

### 3.1 功能目标

让 YFAI 能“自己按时干活”，而不是你每天手动点。

### 3.2 新增功能点

1. 调度任务（Scheduled Jobs）

   * 支持三种调度：

     * Cron 表达式（`0 9 * * *`）
     * 固定间隔（每 X 分钟/小时/天）
     * 一次性任务（run once）
   * 任务类型：

     * 调用某个 Agent 执行指定 goal
     * 调用指定 Workflow 模板
     * 简单执行一次工具调用（例如 ShellOps/NetOps）

2. 事件触发（Triggers）

   * 优先实现几个你本地会用到的：

     * 文件/目录变化触发：监听某目录，新增/修改文件时触发（用于“自动整理下载文件”、“自动入库文档”）
     * 进程状态触发：某进程启动/退出时执行任务（比如 IDE 关闭后自动 commit + push + 生成总结）
     * HTTP Webhook 触发：注册一个本地 HTTP 端点，外部服务（IFTTT、其他系统）调用，即触发任务

3. Automation UI（任务中心）

   * 新增「自动化」页面：

     * 列表：任务名称、触发类型（Cron/事件）、下次执行时间、最近一次结果、启用状态
     * 详情：绑定的 Agent/Workflow、参数（goal、路径、进程名等）
     * 操作：创建/编辑/启用/禁用/立即执行

### 3.3 代码改造点

* 新增模块 `yfai/automation/scheduler.py`

  * 基于 `asyncio` + `apscheduler` 或自己实现简单 scheduler
  * 负责：

    * 维护任务列表（从 DB 加载）
    * 根据触发条件调度执行（调用 Orchestrator / AgentRunner）
* `yfai/store/db.py` 新增：

  * `AutomationTask`：

    * `id`, `name`, `trigger_type`, `cron_expr`, `interval_seconds`, `event_config(json)`, `agent_id/workflow_id`, `params(json)`, `enabled`, `last_run_at`, `last_status`
* Config / UI：

  * `configs/config.example.yaml` 可增加默认调度线程数、日志级别等

---

## 四、Connector Framework：对外服务集成

你已经有 MCP + LocalOps，但它们更偏“工具调用”。要扩到“链接外界”，建议增加一层 Connector 抽象，统一管理各种外部系统（邮箱 / Git / HTTP API 等），并以 MCP/LocalOps 暴露给智能体。

### 4.1 功能目标

* 统一管理外部服务凭据与配置
* 给智能体一个稳定抽象：如 “邮件服务”、“任务系统”，不用关心具体是 Gmail 还是本地 Mail server

### 4.2 新增功能点

1. Connector 抽象

   * 后端新增 `Connector` 接口：

     * `id`, `type`（email/git/http/notes/...）, `config`（json：token、base_url、目录等）
     * 方法：`test_connection()`, `call(action, params)`
   * 类型示例：

     * EmailConnector：收信、发信、搜索
     * GitConnector：clone/pull/push、创建分支、提交日志
     * HttpConnector：配置任意 REST API（URL + 认证头 + 模板）

2. 管理界面

   * 新增「连接器」管理页：

     * 列表：名称、类型、状态（已连接/失败）、最近使用时间
     * 详情：编辑配置、测试连接
   * 可选：在 SettingsDialog 的“Provider / Security”中嵌一部分

3. 对 MCP/LocalOps 的集成方式

   两条路可以并行：

   * 方式 A：将 Connector 暴露为 MCP server 的工具

     * MCP server 的 `tool.list` = 各种 `email.send`, `git.commit`, …
   * 方式 B：在 LocalOps 下新增 `connector.py`，内部路由到指定 connector 实例

   推荐优先 B（实现简单、内聚），未来再用 A 替换。

### 4.3 代码改造点

* 新增 `yfai/connectors/base.py`, `yfai/connectors/email.py`, `yfai/connectors/git.py`, `yfai/connectors/http.py`
* `yfai/store/db.py` 新增 `Connector` 表
* `configs/config.example.yaml` 增加 `connectors:` 区块，便于默认配置

---

## 五、Job & Run 观测台：任务运行可视化与重放

你已有 ToolCall 记录和日志，但偏底层。现在要提升到“对人友好的 Job 视角”。

### 5.1 功能目标

* 每次智能体执行 / 自动化任务 = 一个 Job
* Job 下挂多个 Step（工具调用 / LLM 调用）
* 可以查看过去 Job 的详情、输入/输出、耗时、失败原因
* 可以“一键重跑某步 / 整个 Job”

### 5.2 新增功能点

1. Job 实体

   * 新增 `JobRun` 与 `JobStep` 模型：

     * JobRun：`id`, `type(agent/automation/manual)`, `name`, `status`, `started_at`, `ended_at`, `agent_id`, `automation_id`, `summary`
     * JobStep：`id`, `job_id`, `step_index`, `step_type`（tool/model/fs/...）, `request_snapshot(json)`, `response_snapshot(json)`, `status`, `duration_ms`
   * Orchestrator / AgentRunner / AutomationScheduler 在执行前后统一写 Job 和 Step

2. UI：运行中心

   * 新增「运行记录 / Job」页面：

     * Job 列表：时间、来源（哪个 Agent/任务）、状态、耗时
     * Job 详情：步骤时间线，点击可查看每一步的输入/输出
     * 支持搜索：按时间范围 / 失败状态 / Agent 名称过滤

3. 一键重放

   * 在 Job 详情页提供按钮：

     * “以当前配置重跑该 Job”
     * “从第 X 步继续执行”（适用于中断的任务）

### 5.3 代码改造点

* `yfai/core/orchestrator.py`：

  * 增加简单的 job_run 装饰器，统一写 JobRun/JobStep
* `yfai/store/db.py` 新增 `JobRun`, `JobStep`
* `yfai/security/guard.py` / `policy.py`：

  * Job 视角上增加审批信息（谁批准了哪个 Step）

---

## 六、Personal Workspace：预置几个“你真会用”的场景

你是重度技术用户，建议直接把几个高价值场景做成“一键可用”的模板，而不是给你一堆零件自己拼。

### 6.1 场景 1：代码与项目助手

* 一键创建项目专属 workspace：

  * 指定代码目录 -> 自动建知识库（索引 .py/.go/.md）
  * 预置 Agent：“项目顾问”，绑定目录 + Git Connector
* 提供命令：

  * “总结今日代码变更，生成 changelog.md”
  * “从 issue 列表生成开发计划”

实现上：

* 新增 `ProjectWorkspace` 实体（可选）
* 在 UI 上从“知识库 + Agent + AutomationTask”组合出来

### 6.2 场景 2：系统与网络日常运维

* 定时跑：

  * CPU/内存/磁盘/网络状态
  * 指定端口连通性检查（内网服务/隧道）
  * 将结果汇总为 Markdown 存到某目录（+ 可选发邮件）

直接用：AutomationTask + DevOps Agent + LocalOps(Process/Net/Fs)

### 6.3 场景 3：知识阅读与翻译

* 监控一个“阅读资料”目录：

  * 新增 pdf/txt/markdown -> 自动分块 + 入库 + 生成摘要
  * 提供“今日新增内容摘要”命令/日报

使用：File watcher trigger + VectorIndexer + Bailian/Ollama Chat

---

## 七、安全 & 权限细化

你已经有 SecurityGuard/Policy，但建议增加到“智能体/任务级别”的粒度，让你敢放开更危险的 LocalOps。

### 7.1 功能点

1. 工具授权与等级

   * 在 Agent/AutomationTask 上配置：

     * 允许使用的工具 ID 列表
     * 最大风险等级（高于该等级必须人工审批）

2. 一次性授权

   * 当某个 Agent 第一次尝试调用高风险工具（如 ShellOps 删除文件）：

     * 弹审批窗（你原型里已有模态框交互）
     * 选择“仅这一次允许 / 对该 Agent 永久允许 / 拒绝”

3. 审计视图

   * 在 Job 详情中突出：

     * 哪些步骤触发了审批
     * 最终由谁批准

### 7.2 代码改造点

* `SecurityPolicy`：

  * 增加 `check_agent_permission(agent, tool, risk_level)` 接口
* `Orchestrator`：

  * 在执行工具前，不仅看全局 policy，还看 Agent/AutomationTask 的配置

---

## 八、现有模块的具体改造点汇总

给你一个按代码模块的 Checklist，开发同学可以逐项做：

1. `yfai/core/orchestrator.py`

   * [ ] 新增 `run_agent(...)` / `run_workflow(...)`
   * [ ] 整合 JobRun/JobStep 写入
   * [ ] 与 SecurityGuard 集成 agent-level 权限判定

2. `yfai/store/db.py`

   * [ ] 新增表：`Agent`, `AutomationTask`, `Connector`, `JobRun`, `JobStep`
   * [ ] 可选：`WorkflowTemplate`, `ProjectWorkspace`

3. `yfai/localops/*`

   * [ ] 增加 `connector.py`（或 MCP 方案）
   * [ ] 现有 Fs/Shell/Process/Net 增加更细粒度的风险标记（方便 policy 使用）

4. `yfai/mcp/*`

   * [ ] 预留将 LocalOps/Connectors 包装为 MCP server 的能力（暂不必全做）

5. `yfai/app/*`

   * [ ] Sidebar：增加「智能体」「自动化」「运行记录」「连接器」入口
   * [ ] ChatWidget：支持“以某个 Agent 运行”的模式切换
   * [ ] 新增页面：

     * Agent 管理
     * Automation 管理
     * JobRun 列表 & 详情
     * Connector 管理

6. `configs/config.example.yaml`

   * [ ] 新增 `agents`, `automation`, `connectors` 示例配置
   * [ ] 扩展 security 部分：默认风险阈值、默认危险工具列表

---

## 九、实施顺序建议（给自己减少折腾）

建议分三期做，不要一次性全糊：

1. Phase 1：Agent + JobRun

   * 先把 Agent 定义 / run_agent / JobRun/JobStep 打通
   * 可以先不做 UI，全用命令面板或简单按钮触发

2. Phase 2：Automation + Personal Scenarios

   * 上 Scheduler + AutomationTask
   * 实现 2–3 个你日常真会用的自动化场景（项目总结、系统巡检、知识入库）

3. Phase 3：Connector + 对外扩展

   * 做几个你真需要的 Connector（Git + Email/HTTP）
   * 再考虑通过 MCP 暴露出去，给其他客户端用
